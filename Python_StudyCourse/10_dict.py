r'''
字典 dict



'''
# 莫斯密码
# 密文表
c_table = ['·-', '-···','-·-·', '-··', '·', '··-·', '--·', '····', '··', '·---', '-·-', '·-··',\
           '--', '-·', '---', '·--·', '--·-', '·-·', '···', '-', '··-', '···-', '·--', '-··-',\
            '-·--', '--··', '·----', '··---', '···--', '····-', '·····', '-····', '--···', '---··',\
                '----·', '-----']
# 明文表
d_table = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'G', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
           'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0']

need_cracked_Morse_Code = ['···', '····', '·-', '-·', '--·', '····', '·-', '··', '--··', '··', '·-··', '·-',\
                           '··', '···', '····', '··-', '··', '·-··', '·-', '··', '--··', '··', '····', '·-',\
                            '··', '···', '····', '·-', '-·', '--·']

Morse_Code_result = [d_table[c_table.index(i)] for i in need_cracked_Morse_Code ]
'''for i in need_cracked_Morse_Code:
    if i in c_table:
        _ = c_table.index(i)
        Morse_Code_result.append(d_table[_])'''
for i in Morse_Code_result:
    print(i, end = '')

# 以上表明, 列表可以模仿字典映射关系

'''
{:} 是创建字典的关键符号
x = {'吕布':'口口布', '关羽':'关习习'}
{键:值}
可以通过dict对象的键来获取该键的值
x['吕布'] 
'口口布'
通过指定一个不存在字典对象中的键, 可以创建一个新的键值对
x['刘宝贝'] = '刘baby'
对象 x 中就创建了了新的键值对 {'吕布':'口口布', '关羽':'关习习', '刘宝贝':'刘baby'}

字典中的键不会重复, 如果重复了就会用最新的键值覆盖前面的键值

创建字典的方法:
1. x = {'吕布':'口口布', '关羽':'关习习'}
2. y = dict(吕布 = '口口布', 关羽 = '关习习', 刘宝贝 = '刘baby')   这种写法不可在键上加引号
3. z = dict([('吕布', '口口布'), ('关羽', '关习习'), ('刘宝贝', '刘baby')])   使用列表作为参数, 列表中的每个元素是使用元组包裹起来的键值对
4. a = dict({'吕布':'口口布', '关羽':'关习习'})
5. b = dict({'吕布':'口口布', '关羽':'关习习'}, 刘备 = '刘baby')   也可以混合创建, 混合创建时{}外的参数, 创建变量要使用创建变量的规则, 刘备 = '刘baby' 变量不能为数字, _
6. c = dict(zip(['吕布', '关羽', '刘备'], ['口口布', '关习习', '刘baby']))   使用zip函数作为参数, 打包传给dict

字典的增删改查
增: fromkeys(iterabal[, value])
d = dict.fromkeys('fishc', 520)
{'f': 520, 'i': 520, 's': 520, 'h': 520, 'c': 520}
适用于从无到有创建一个所有键的值都相同的字典
如果要修改可以 d['f'] = 70  修改后的结果就是 {'f': 70, 'i': 520, 's': 520, 'h': 520, 'c': 520}
如果找不到对应的键, 就会变为新增一个键值对 例如, d['p'] = 80   修改后的结果就是, {'f': 70, 'i': 520, 's': 520, 'h': 520, 'c': 520, 'p':80}

删:
pop(key[, default])  这个方法会返回删除键对应的值, 比如删除 d 中的'f', 会返回一个520
d = {'f': 520, 'i': 520, 's': 520, 'h': 520, 'c': 520}
d.pop('s') 删除后的结果就是 {'i': 520, 's': 520, 'h': 520, 'c': 520, 'p': 80}
如果pop一个不存在的键就会抛出异常
d.pop('A')
KeyError: 'A'
default 可以指定当pop一个不存在的键时抛出的异常, d.pop('A', '没有A'), 那么就会返回'没有A'
popitem() python3.7之前这个方法随机删除一个键值对, 3.7之后删除最后一个加入字典的键值对, 然后会返回删除的这个键值对
d.popitem() 删除之后的结果就是 {'i': 520, 's': 520, 'h': 520, 'c': 520}, 返回'p': 80
del 可以指定删除一个字典元素
del['i'] 删除之后的结果就是 {'s': 520, 'h': 520, 'c': 520}
del 可以删除整个字典对象, del d, 执行之后 d就不在了
clear()
d = dict.fromkeys('fishc', 520)
d.clear() 删除之后 d就成了一个空的字典{}

改:
修改字典的某个键对应的值, 即可完成该键值的修改
d = dict.fromkeys('fishc', None)
d['f'] = 15    d就变成了 {'f': 15, 'i': None, 's': None, 'h': None, 'c': None}
update()
update()方法可以支持同时给他传入多个键值对, 也可以给他传入另一个字典进去, 或者一个包含键值对的可迭代对象
d.update()
d.update({'i':105, 'h':104})  结果为 {'f': None, 'i': 105, 's': None, 'h': 104, 'c': None}
或者 d.update(f = '66', c = '67')

查:
d['c'] 就会返回 67, 但是如果查一个字典中不存在的键, 那么会报错
get()
d.get('c') 返回67
get()可以定义一个自定义参数, 用来找不到该键的时候 返回自定义的值
d.get('K', '该键不存在') 则返回'该键不存在'
setdefault() 查找一个键是否存在字典中, 如果在返回该键的值, 如果不在指定一个新值
d.setdefault('f', 'hi') 返回66, 因为'f'在字典中, 该键的值为66, 所以返回66; default code 不起作用
d.setdefault('H', 'hi') 返回'hi', 因为'H'不字典中, 该键的值为66, 设置default code值为'hi', 所以返回 'hi' 
items() 获取字典的键值对的视图对象
itmes = d.items()
keys()获取字典的键的视图对象
keys = d.keys()
values()获取字典的值的视图对象
values = d.values()
当字典内容发生改变的时候, itmes, keys, values 的内容都会随着改变, 不管新增键值对还是删除键值对
copy()
copy()方法用来复制, 浅拷贝第一层的修改是不会相互影响的, 但是对于嵌套层, 数据就会跟着改变(同列表)
s = d.copy()
len()可以获取字典键值对的数量
in 和 not in 可以判断某个键是否存在于字典中
使用list()也可以将字典转换为列表, 得到字典中所有的键构成的列表(只有键, 不含键的值)
iter()也可以用于字典, 将字典的键构成一个迭代器

字典可以使用reversed()函数进行排序, python 3.8版本之后就行
list(reversed(d.keys()))
字典有嵌套, 例如 d = {'吕布':{'语文':80, '数学':88, '英语':87}, '关羽':{'语文':99, '数学':89, '英语':88}, '刘备':{'语文':79, '数学':78, '英语':99}}
d['吕布']['语文'] 就返回80
也可以嵌套一个列表 d = {'吕布':[60, 70, 80], '关羽':[88, 90, 56], '刘备':[90, 56, 77]}
d['吕布'][0] 就返回60

字典推导式
d = {'f':105, 'i':115, 's':99, 'h':78, 'c':99}
b = {k:v for k, v in d.items() if v > 80}

'''

