r'''
字典 dict



'''
# 莫斯密码
# 密文表
c_table = ['·-', '-···','-·-·', '-··', '·', '··-·', '--·', '····', '··', '·---', '-·-', '·-··',\
           '--', '-·', '---', '·--·', '--·-', '·-·', '···', '-', '··-', '···-', '·--', '-··-',\
            '-·--', '--··', '·----', '··---', '···--', '····-', '·····', '-····', '--···', '---··',\
                '----·', '-----']
# 明文表
d_table = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'G', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
           'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0']

need_cracked_Morse_Code = ['···', '····', '·-', '-·', '--·', '····', '·-', '··', '--··', '··', '·-··', '·-',\
                           '··', '···', '····', '··-', '··', '·-··', '·-', '··', '--··', '··', '····', '·-',\
                            '··', '···', '····', '·-', '-·', '--·']

Morse_Code_result = [d_table[c_table.index(i)] for i in need_cracked_Morse_Code ]
'''for i in need_cracked_Morse_Code:
    if i in c_table:
        _ = c_table.index(i)
        Morse_Code_result.append(d_table[_])'''
for i in Morse_Code_result:
    print(i, end = '')

# 以上表明, 列表可以模仿字典映射关系

'''
{:} 是创建字典的关键符号
x = {'吕布':'口口布', '关羽':'关习习'}
{键:值}
可以通过dict对象的键来获取该键的值
x['吕布'] 
'口口布'
通过指定一个不存在字典对象中的键, 可以创建一个新的键值对
x['刘宝贝'] = '刘baby'
对象 x 中就创建了了新的键值对 {'吕布':'口口布', '关羽':'关习习', '刘宝贝':'刘baby'}

字典中的键不会重复, 如果重复了就会用最新的键值覆盖前面的键值

创建字典的方法:
1. x = {'吕布':'口口布', '关羽':'关习习'}
2. y = dict(吕布 = '口口布', 关羽 = '关习习', 刘宝贝 = '刘baby')   这种写法不可在键上加引号
3. z = dict([('吕布', '口口布'), ('关羽', '关习习'), ('刘宝贝', '刘baby')])   使用列表作为参数, 列表中的每个元素是使用元组包裹起来的键值对
4. a = dict({'吕布':'口口布', '关羽':'关习习'})
5. b = dict({'吕布':'口口布', '关羽':'关习习'}, 刘备 = '刘baby')   也可以混合创建, 混合创建时{}外的参数, 创建变量要使用创建变量的规则, 刘备 = '刘baby' 变量不能为数字, _
6. c = dict(zip(['吕布', '关羽', '刘备'], ['口口布', '关习习', '刘baby']))   使用zip函数作为参数, 打包传给dict

字典的增删改查
增: fromkeys(iterabal[, value])
d = dict.fromkeys('fishc', 520)
{'f': 520, 'i': 520, 's': 520, 'h': 520, 'c': 520}
适用于从无到有创建一个所有键的值都相同的字典
如果要修改可以 d['f'] = 70  修改后的结果就是 {'f': 70, 'i': 520, 's': 520, 'h': 520, 'c': 520}
如果找不到对应的键, 就会变为新增一个键值对 例如, d['p'] = 80   修改后的结果就是, {'f': 70, 'i': 520, 's': 520, 'h': 520, 'c': 520, 'p':80}

删:
pop(key[, default])  这个方法会返回删除键对应的值, 比如删除 d 中的'f', 会返回一个520
d = {'f': 520, 'i': 520, 's': 520, 'h': 520, 'c': 520}
d.pop('s') 删除后的结果就是 {'i': 520, 's': 520, 'h': 520, 'c': 520, 'p': 80}
如果pop一个不存在的键就会抛出异常
d.pop('A')
KeyError: 'A'
default 可以指定当pop一个不存在的键时抛出的异常, d.pop('A', '没有A'), 那么就会返回'没有A'
popitem() python3.7之前这个方法随机删除一个键值对, 3.7之后删除最后一个加入字典的键值对, 然后会返回删除的这个键值对
d.popitem() 删除之后的结果就是 {'i': 520, 's': 520, 'h': 520, 'c': 520}, 返回'p': 80
del 可以指定删除一个字典元素
del['i'] 删除之后的结果就是 {'s': 520, 'h': 520, 'c': 520}
del 可以删除整个字典对象, del d, 执行之后 d就不在了
clear()
d = dict.fromkeys('fishc', 520)
d.clear() 删除之后 d就成了一个空的字典{}


'''

