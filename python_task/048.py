'''
0. 迭代器可以看作是一种特殊的生成器吗？
答: 错, 生成器可以看作一种特殊的迭代器, 而不是迭代器可以看作是一种特殊的生成器

1. 生成器是否支持下标索引？
答: 不可以, 生成器不可进行下标索引, 生成器可以看作一个制作机器, 每次只制作一件产品

2. 生成器可以看作是 Python 对于 “延迟执行” 提供的技术支持，这种说法正确吗？
答: 正确  在需要的时候才产生结果，而并非一次性生产，这就是 “延迟执行” 的含义, 当然，通过闭包
我们也可以实现类似的效果，不过生成器毕竟是 Python 帮我们定义好的语句，用起来肯定要顺手方便很多。

3. 你觉得生成器通常应用在什么场景会比较合适？
答: 读取超大文件, 读取无限序列, 优化内存等场景都比较合适

4. 请问下面代码会打印 “YES” 吗？
>>> def counter():
...     i = 0
...     while i <= 5:
...         yield i
...         i += 1
...     print("YES")
...
>>> for each in counter():
...     print(each)
答: 会打印, 当while 语句执行完毕后, 会执行函数内的打印操作, 函数内与return不同, 如果是return 了就不会走了, 如果是yield则会继续

5. 生成器表达式和列表推导式的最大区别是什么？
答: 生成器表达式每次只生产一个数据; 列表推导式一次将所有的数据计算出来

6. 下面这个列表推导式是不是有什么问题？为什么一直不出结果，你有什么办法解决这个问题么？
>>> [x ** 2 for x in range(1000000)]
答: 像这种情况我们就可以采用生成器表达式, 因为只有你在用到他的时候他才会去计算, 且每次只计算一次, 返回一个计算的结果
(x **2 for i in range(100000000000000))

7. 请将下面的 map() 函数实现改为使用生成器表达式实现。
>>> list(map(abs, (-1, 2, -3, 4, -5)))
[1, 2, 3, 4, 5]
答: list((abs(i) for i in range(5)))

8. 请将下面的生成器表达式实现改为使用 filter() 函数实现。
>>> "".join(x for x in "FishC" if x.isupper())
'FC'
答: ''.join(filter(str.isupper, 'FishC'))

9. 请问下面代码会打印什么内容？
list(map(lambda x : x ** 2, filter(lambda x : x % 2 == 0, range(10))))
答: 打印 10以内偶数的2次方 [0, 4, 16, 36, 64]

利用生成器定义一个支持浮点数的 frange() 函数，其功能与 range() 函数相仿。
默认的步进值为 0.1:
>>> for i in frange(1):
...     print(i)
...
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1.0
支持设置起始位置和结束位置：
>>> for i in frange(1, 2):
...     print(i)
...
1.0
1.1
1.2
1.3
1.4
1.5
1.6
1.7
1.8
1.9
当然也支持设置步进精度：
>>> for i in frange(5, 10, 0.5):
...     print(i)
...        
5.0
5.5
6.0
6.5
7.0
7.5
8.0
8.5
9.0
9.5 
小甲鱼特别提示：由于 IEEE745 导致的浮点数误差问题，推荐大家考虑使用 round() 函数来修正其浮点误差的结果
'''
def frange(a, b=0, c=0.1):
    if b > a:
        init_data = a
    else:
        init_data = 0
    if b > a:
        while init_data < b:
            yield float(round(init_data, 1))
            init_data += c
    else:
        while init_data < a:
            yield float(round(init_data, 1))
            init_data += c

f = frange(5, 10, 0.5)
for i in f:
    print(i)